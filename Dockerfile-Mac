# 打包环境
FROM arm64v8/maven:3.9.11-amazoncorretto-17-alpine AS builder
WORKDIR /opt/springboot-vue-admin

# apk镜像源
RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories

# 安装 npm && pnpm
RUN apk update && apk add npm && apk add pnpm

# pnpm镜像源
RUN pnpm config set registry http://registry.npmmirror.com

# 创建文件夹
RUN mkdir admin-backend
RUN mkdir admin-frontend

# maven依赖缓存层
COPY pom.xml .
COPY admin-backend/pom.xml ./admin-backend
COPY admin-frontend/pom.xml ./admin-frontend
RUN mvn -B -Paliyun dependency:go-offline

# npm依赖缓存层
COPY admin-frontend/package.json ./admin-frontend
COPY admin-frontend/pnpm-lock.yaml ./admin-frontend
RUN pnpm install --prefix ./admin-frontend

# copy项目
COPY . .

# maven打包
RUN mvn -B -Paliyun -Dmaven.test.skip=true package

# 运行环境
FROM arm64v8/eclipse-temurin:17.0.16_8-jre-ubi10-minimal
WORKDIR /opt

# 声明暴露端口（这并不意味着容器启动时会自动开启这些端口服务）
EXPOSE 8080

# 复制jar包
COPY --from=builder /opt/springboot-vue-admin/admin-backend/target/admin-backend-*.jar ./app.jar

# 运行（默认运行的是开发环境）
# 1、ENTRYPOINT不会被docker run的参数覆盖；CMD会被覆盖
# 2、exec模式不会解析变量；shell模式可以解析变量，但是会有信号接收问题（推荐使用exec模式）
ENTRYPOINT ["java", "-jar", "/opt/app.jar"]
CMD ["--server.port=8080", "--spring.profiles.active=dev"]

# 构建镜像
# docker build -t sv-admin .
# 运行容器（开发环境）
# docker run -itd -p 8080:8080 --name sv-admin sv-admin:latest
# 运行容器（生产环境）
# docker run -itd -p 8080:8080 --name sv-admin sv-admin:latest --server.port=8080 --spring.profiles.active=prod --mpw.key=xxxx