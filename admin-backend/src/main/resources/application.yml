server:
  port: 8080
  servlet:
    encoding:
      force: true #请求、响应编码问题
spring:
  application:
    name: sv-admin
  profiles:
    active: dev

  # 事务配置
  transaction:
    default-timeout: 60s #事务超时时间
    rollback-on-commit-failure: true #提交失败回滚

  # 文件上传配置
  servlet:
    multipart:
      max-file-size: 16MB #单个文件大小
      max-request-size: 32MB #总上传的文件大小

  # jackson配置
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+8
    default-property-inclusion: always
    serialization:
      write-enums-using-to-string: true
      write-dates-as-timestamps: false
    deserialization:
      read-enums-using-to-string: true
      read-unknown-enum-values-using-default-value: true
      fail-on-unknown-properties: false

  # http client配置
  http:
    client:
      factory: http_components
      redirects: dont_follow
      connect-timeout: 5s
      read-timeout: 60s

  # 缓存配置（如果要启用redis缓存，需要修改redis配置）
  cache:
    type: caffeine
    redis:
      key-prefix: "sv-admin::" #缓存key前缀
      time-to-live: 1h #缓存过期时间
      cache-null-values: false #是否存储空值
      use-key-prefix: true #是否使用key前缀
    caffeine:
      spec: initialCapacity=10,maximumSize=100,expireAfterAccess=5m

  # spring ai配置
  ai:
    openai:
      base-url: https://dashscope.aliyuncs.com/compatible-mode
      api-key: ${AI_DASHSCOPE_API_KEY}
      chat:
        options:
          model: qwen-flash
        completions-path: /v1/chat/completions
    chat:
      memory:
        repository:
          jdbc:
            initialize-schema: never
    retry:
      max-attempts: 1

  # redis配置
  data:
    redis:
      database: 0
      password: 123456
      host: 127.0.0.1
      port: 6379
      connect-timeout: 5s #连接超时
      timeout: 5s #读取超时
      lettuce:
        pool:
          max-active: 8 #最大连接数
          max-idle: 5 #最大空闲连接数
          min-idle: 1 #最小空闲连接数
          max-wait: 5s #从连接池获取连接超时时间
          time-between-eviction-runs: 5m #空闲连接检查间隔

  # Quartz配置，参考：SchedulerFactoryBean.initSchedulerFactory
  quartz:
    scheduler-name: sv-admin #集群名称
    job-store-type: jdbc #存储器类型，默认为 memory
    auto-startup: true #是否自动启动
    startup-delay: 0s #启动延迟
    wait-for-jobs-to-complete-on-shutdown: true #应用关闭时，是否等待定时任务执行完成，默认为 false
    overwrite-existing-jobs: true #是否覆盖已有Job的配置，仅适用于Bean注册
    properties: #quartz附加属性，参考：http://www.quartz-scheduler.org/documentation/2.4.0-SNAPSHOT/configuration.html
      org:
        quartz:
          # Scheduler配置
          scheduler:
            #instanceName: 不需要配置，同 spring.quartz.scheduler-name
            instanceId: AUTO #自动生成 instanceID
            instanceIdGenerator:
              class: org.quartz.simpl.SimpleInstanceIdGenerator #id生成策略类，默认为 SimpleInstanceIdGenerator
          # JobStore 相关配置
          jobStore:
            class: org.springframework.scheduling.quartz.LocalDataSourceJobStore #JobStore实现类
            #driverDelegateClass: 在 EnvironmentConfiguration 类中动态配置
            tablePrefix: QRTZ_ #Quartz表前缀
            isClustered: true #是集群模式
            clusterCheckinInterval: 15000 #集群检查频率，单位：毫秒。默认为 15000
            misfireThreshold: 60000 #允许任务在错过触发时间后自动重试，比如任务暂停时间在60秒之内，那么期间没有执行的任务会补充执行
            useProperties: false
    jdbc:
      initialize-schema: never #不初始化数据库

  # 线程池配置，参考：TaskExecutorConfigurations.TaskExecutorConfiguration.applicationTaskExecutor
  task:
    execution:
      quartz:
        pool:
          core-size: 1
          max-size: 5
          queue-capacity: 50
          keep-alive: 60s
          allow-core-thread-timeout: true
        shutdown:
          await-termination: true
          await-termination-period: 30s
        thread-name-prefix: quartz-
      ai:
        pool:
          core-size: 1
          max-size: 5
          queue-capacity: 50
          keep-alive: 60s
          allow-core-thread-timeout: true
        shutdown:
          await-termination: true
          await-termination-period: 30s
        thread-name-prefix: ai-

# 关闭 swagger-ui，前端已经整合
springdoc:
  swagger-ui:
    enabled: false

# mybatis-plus
mybatis-plus:
  configuration:
    jdbc-type-for-null: "null" #解决oracle插入null值报错：一定得带双引号或者单引号，不然值设置不进去
  global-config:
    db-config:
      id-type: none #由 EnvironmentConfiguration 动态设置成 AUTO 或者 INPUT 模式
#      id-type: auto #自增ID，适合 MySQL 等直接自增的数据库
#      id-type: input #用户输入ID，适合 Oracle、PostgreSQL、Kingbase、DB2、H2 数据库
#      id-type: assign_id #分配ID，默认使用雪花算法。注意，Oracle、PostgreSQL、Kingbase、DB2、H2 数据库时，需要去除实体类上的 @KeySequence 注解

# 指标监控
management:
  observations:
    annotations:
      enabled: true
  health:
    redis:
      enabled: false #禁用redis健康检查，redis不一定启用

# 自定义配置
custom:
  # 重置默认密码
  user:
    default-password: 123456
  # jwt配置
  jwt:
    access:
      key: LyGR^*tpCYA&c#HMeJDndUKPShTrX%F!
      expiration: 1d
    refresh:
      key: Y$tDyV!Sx&XZMnqT^AEpkQ#Wgvcs%F@w
      expiration: 7d
  # http连接池配置
  http:
    rest-client:
      pool:
        max-total: 100 #最大连接数
        max-per-route: 10 #每个路由最大连接数
        obtain-connect-timeout: 5s #获取连接超时
      connect:
        connect-timeout: 5s #连接超时
        socket-timeout: 60s #读取超时
        default-keep-alive: 60s #默认保活时间
    web-client:
      pool:
        max-total: 100 #最大连接数
        max-per-route: 10 #每个路由最大连接数
        obtain-connect-timeout: 5s #获取连接超时
      connect:
        connect-timeout: 5s #连接超时
        socket-timeout: 60s #读取超时
        default-keep-alive: 60s #默认保活时间
  # jsqlParser解析缓存
  jsql-parser:
    cache:
      spec: initialCapacity=10,maximumSize=100,expireAfterAccess=1m